/*
* Nesora 0 type IV
* Copyright (c) MucchoSP. All right reserved.
* 
* 
* This file is encoded in Shift-JIS.
* 
* 音諳用に作成したwaveファイルの保存プログラムです。
* 
*/
#pragma once

#include <string>
#include <vector>
#include <fstream>

#include "Nesoraint.h"

namespace nesora {

	//音諳の音声データを.wavに保存する為のクラス
	template<class T>
	class NesoraWave {
	private:

		std::vector<T> wave;

		nssmpl_t samplingFreq = 44100;				//標本化周波数
		uint16_t channelNum = 1;					//チャンネル数
		uint16_t bitPerSample = sizeof(T) * 8;		//量子化ビット数

		std::string	INAM = "Nesora Voice";	//タイトル
		std::string	IPRD = "Nesora";	//アルバム名
		std::string IART = "MucchoSP";	//アーティスト名
		std::string	ICMT = "This is an audio file generated by Nesora.";	//コメント
		std::string	ICRD = "After 2024";	//作成日
		std::string	IGNR = "Voice";	//ジャンル
		std::string	ITRK = "0";	//トラック
		std::string	ICMS = "None";	//依頼者
		std::string	ICOP = "Copyright (c) MucchoSP";	//著作権情報
		std::string ISFT = "Nesora 0 type IV";	//ファイル作成に使用したソフトウエア名
		
	public:

		NesoraWave() {

		}
		NesoraWave(std::vector<T> w) {
			wave = w;
		}

		void SetWave(std::vector<T> w) {
			wave = w;
		}
		std::vector<T> GetWave() {
			return wave;
		}

		int SaveFile(std::string fileName) {
			std::ofstream file(fileName, std::ios::binary);

			if (!file)
				return -1;

			uint32_t work32 = 0;
			uint16_t work16 = 0;
			uint8_t work8 = 0;

			file << "RIFF";
			auto fileSize = file.tellp();
			work32 = 0;//riff chank size
			file.write((char*)&work32, 4);
			file << "WAVE";

			file << "fmt ";
			work32 = 16;					//format chank size
			file.write((char*)&work32, 4);
			work16 = 1;						//format tag(WAVE_FORMAT_PCM:PCM)
			file.write((char*)&work16, 2);
			file.write((char*)&channelNum, 2);
			file.write((char*)&samplingFreq, 4);
			work32 = samplingFreq * channelNum * (bitPerSample / 8);
			file.write((char*)&work32, 4);
			work16 = channelNum * (bitPerSample / 8);
			file.write((char*)&work16, 2);
			file.write((char*)&bitPerSample, 2);
			//fmt チャンクここまで

			file << "data";
			int padding = 2 /*- wave.size() % 2*/;
			file.write((char*)&(work32 = wave.size() * (channelNum * bitPerSample / 8) + padding), 4);	//data chank size
			file.write((char*)wave.data(), wave.size() * (bitPerSample / 8));
			file.write((char*)&(work32 = 0), padding);
			//dataチャンクここまで

			work16 = 0;
			file << "LIST";
			auto ListSize = file.tellp();
			file.write((char*)&(work32 = 0), 4);
			file << "INFO";
			//製作者
			std::string workInfoString = IART;
			if (workInfoString != "") {
				file << "IART";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//依頼者
			workInfoString = ICMS;
			if (workInfoString != "") {
				file << "ICMS";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "ICMT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "ICOP";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "ICRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "IGNR";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "INAM";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "IPRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ソフトウエア名
			workInfoString = ISFT;
			if (workInfoString != "") {
				file << "ISFT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "ITRK";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}

			int ListSize_work32 = file.tellp() - ListSize - 4;
			auto ListChankEnd = file.tellp();
			file.seekp(ListSize);
			file.write((char*)&ListSize_work32, 4);
			file.seekp(ListChankEnd);
			//LISTチャンクここまで


			file << "id3 ";
			auto id3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			file << "ID3";
			file.write((char*)&(work16 = 3), 2);
			file.write((char*)&(work8 = 0), 1);
			auto ID3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			int is_ShiftJIS = 1;
			//製作者
			workInfoString = IART;
			if (workInfoString != "") {
				file << "TPE1";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + is_ShiftJIS)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "COMM";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "TCOP";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "TDAT";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "TCON";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "TIT2";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "TALB";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ソフトウエア名
			/*workInfoString = info.ISFT;
			if (workInfoString == "")
				workInfoString = "Nesora I type IV";
			file << "ISFT";
			file.write((char*)&(work8 = (workInfoString.size() >> 24) % 0xff), 1);
			file.write((char*)&(work8 = (workInfoString.size() >> 16) % 0xff), 1);
			file.write((char*)&(work8 = (workInfoString.size() >> 8) % 0xff), 1);
			file.write((char*)&(work8 = workInfoString.size() % 0xff), 1);
			file.write((char*)&(work16 = 0), 2);
			file.write(workInfoString.data(), workInfoString.size());*/

			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "TRCK";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}

			int ID3Size_work32 = file.tellp() - ID3Size - 4;
			int id3Size_work32 = file.tellp() - id3Size - 4;
			int fileSize_work32 = file.tellp() - fileSize - 4;
			file.seekp(ID3Size);
			file.write((char*)&(work8 = (ID3Size_work32 >> 21) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 14) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 7) % 0x7f), 1);
			file.write((char*)&(work8 = ID3Size_work32 % 0x7f), 1);
			//ID3 チャンクここまで

			file.seekp(id3Size);
			file.write((char*)&id3Size_work32, 4);
			//id3 チャンクここまで

			file.seekp(fileSize);
			file.write((char*)&fileSize_work32, 4);
			//RIFFチャンクここまで


			file.close();
		}

		void SetSamplingFrequency(nssmpl_t samplingFrequency) {
			samplingFreq = samplingFrequency;
		}
		void SetChannelNumber(uint16_t channelNumber) {
			channelNum = channelNumber;
		}

		nssmpl_t GetSamplingFrequency() {
			return samplingFreq;
		}
		uint16_t GetChannelNumber() {
			return channelNum;
		}
		uint16_t GetBitPerSample() {
			return bitPerSample;
		}

		void SetTitle(std::string title) {
			INAM = title;
		}
		void SetProductName(std::string name) {
			IPRD = name;
		}
		void SetArtistName(std::string name) {
			IART = name;
		}
		void SetComment(std::string comment) {
			ICMT = comment;
		}
		void SetCreationDate(std::string date) {
			ICRD = date;
		}
		void SetGenre(std::string genre) {
			IGNR = genre;
		}
		void SetTrackNumber(std::string number) {
			ITRK = number;
		}
		void SetClient(std::string client) {
			ICMS = client;
		}
		void SetCopyright(std::string copyright) {
			ICOP = copyright;
		}
		void SetSoftware(std::string software) {
			ISFT = software;
		}

		std::string GetTitle() {
			return INAM;
		}
		std::string GetProductName() {
			return IPRD;
		}
		std::string GetArtistName() {
			return IART;
		}
		std::string GetComment() {
			return ICMT;
		}
		std::string GetCreationDate() {
			return ICRD;
		}
		std::string GetGenre() {
			return IGNR;
		}
		std::string GetTrackNumber() {
			return ITRK;
		}
		std::string GetClient() {
			return ICMS;
		}
		std::string GetCopyright() {
			return ICOP;
		}
		std::string GetSoftware() {
			return ISFT;
		}

	};

	//音諳の浮動小数点数型の音声データを.wavに保存する為のクラス
	/*
	template<>
	class NesoraWave<float> {
	private:

		std::vector<float> wave;

		nssmpl_t samplingFreq = 44100;				//標本化周波数
		uint16_t channelNum = 1;					//チャンネル数
		uint16_t bitPerSample = sizeof(float) * 8;		//量子化ビット数

		std::string	INAM = "Nesora Voice";	//タイトル
		std::string	IPRD = "Nesora";	//アルバム名
		std::string IART = "MucchoSP";	//アーティスト名
		std::string	ICMT = "This is an audio file generated by Nesora.";	//コメント
		std::string	ICRD = "After 2024";	//作成日
		std::string	IGNR = "Voice";	//ジャンル
		std::string	ITRK = "0";	//トラック
		std::string	ICMS = "None";	//依頼者
		std::string	ICOP = "Copyright (c) MucchoSP";	//著作権情報
		std::string ISFT = "Nesora 0 type IV";	//ファイル作成に使用したソフトウエア名

	public:

		NesoraWave() {

		}
		NesoraWave(std::vector<float> w) {
			wave = w;
		}

		void SetWave(std::vector<float> w) {
			wave = w;
		}
		std::vector<float> GetWave() {
			return wave;
		}

		int SaveFile(std::string fileName) {
			std::ofstream file(fileName, std::ios::binary);

			if (!file)
				return -1;

			uint32_t work32 = 0;
			uint16_t work16 = 0;
			uint8_t work8 = 0;

			file << "RIFF";
			auto fileSize = file.tellp();
			work32 = 0;//riff chank size
			file.write((char*)&work32, 4);
			file << "WAVE";

			file << "fmt ";
			work32 = 16;					//format chank size
			file.write((char*)&work32, 4);
			work16 = 3;						//format tag(WAVE_FORMAT_IEEE_FLOAT:IEEE float)
			file.write((char*)&work16, 2);
			file.write((char*)&channelNum, 2);
			file.write((char*)&samplingFreq, 4);
			work32 = samplingFreq * channelNum * (bitPerSample / 8);
			file.write((char*)&work32, 4);
			work16 = channelNum * (bitPerSample / 8);
			file.write((char*)&work16, 2);
			file.write((char*)&bitPerSample, 2);
			//fmt チャンクここまで

			file << "data";
			int padding = 2;
			file.write((char*)&(work32 = wave.size() * (channelNum * bitPerSample / 8) + padding), 4);	//data chank size
			file.write((char*)wave.data(), wave.size() * (bitPerSample / 8));
			file.write((char*)&(work32 = 0), padding);
			//dataチャンクここまで

			work16 = 0;
			file << "LIST";
			auto ListSize = file.tellp();
			file.write((char*)&(work32 = 0), 4);
			file << "INFO";
			//製作者
			std::string workInfoString = IART;
			if (workInfoString != "") {
				file << "IART";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//依頼者
			workInfoString = ICMS;
			if (workInfoString != "") {
				file << "ICMS";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "ICMT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "ICOP";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "ICRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "IGNR";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "INAM";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "IPRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ソフトウエア名
			workInfoString = ISFT;
			if (workInfoString != "") {
				file << "ISFT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "ITRK";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}

			auto ListSize_work32 = file.tellp() - ListSize - 4;
			auto ListChankEnd = file.tellp();
			file.seekp(ListSize);
			file.write((char*)&ListSize_work32, 4);
			file.seekp(ListChankEnd);
			//LISTチャンクここまで


			file << "id3 ";
			auto id3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			file << "ID3";
			file.write((char*)&(work16 = 3), 2);
			file.write((char*)&(work8 = 0), 1);
			auto ID3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			int is_ShiftJIS = 1;
			//製作者
			workInfoString = IART;
			if (workInfoString != "") {
				file << "TPE1";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + is_ShiftJIS)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "COMM";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "TCOP";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "TDAT";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "TCON";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "TIT2";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "TALB";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ソフトウエア名
			// workInfoString = info.ISFT;
			// if (workInfoString == "")
			// 	workInfoString = "Nesora I type IV";
			// file << "ISFT";
			// file.write((char*)&(work8 = (workInfoString.size() >> 24) % 0xff), 1);
			// file.write((char*)&(work8 = (workInfoString.size() >> 16) % 0xff), 1);
			// file.write((char*)&(work8 = (workInfoString.size() >> 8) % 0xff), 1);
			// file.write((char*)&(work8 = workInfoString.size() % 0xff), 1);
			// file.write((char*)&(work16 = 0), 2);
			// file.write(workInfoString.data(), workInfoString.size());

			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "TRCK";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}

			auto ID3Size_work32 = file.tellp() - ID3Size - 4;
			auto id3Size_work32 = file.tellp() - id3Size - 4;
			auto fileSize_work32 = file.tellp() - fileSize - 4;
			file.seekp(ID3Size);
			file.write((char*)&(work8 = (ID3Size_work32 >> 21) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 14) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 7) % 0x7f), 1);
			file.write((char*)&(work8 = ID3Size_work32 % 0x7f), 1);
			//ID3 チャンクここまで

			file.seekp(id3Size);
			file.write((char*)&id3Size_work32, 4);
			//id3 チャンクここまで

			file.seekp(fileSize);
			file.write((char*)&fileSize_work32, 4);
			//RIFFチャンクここまで


			file.close();

			return 0;
		}

		void SetSamplingFrequency(nssmpl_t samplingFrequency) {
			samplingFreq = samplingFrequency;
		}
		void SetChannelNumber(uint16_t channelNumber) {
			channelNum = channelNumber;
		}

		nssmpl_t GetSamplingFrequency() {
			return samplingFreq;
		}
		uint16_t GetChannelNumber() {
			return channelNum;
		}
		uint16_t GetBitPerSample() {
			return bitPerSample;
		}

		void SetTitle(std::string title) {
			INAM = title;
		}
		void SetProductName(std::string name) {
			IPRD = name;
		}
		void SetArtistName(std::string name) {
			IART = name;
		}
		void SetComment(std::string comment) {
			ICMT = comment;
		}
		void SetCreationDate(std::string date) {
			ICRD = date;
		}
		void SetGenre(std::string genre) {
			IGNR = genre;
		}
		void SetTrackNumber(std::string number) {
			ITRK = number;
		}
		void SetClient(std::string client) {
			ICMS = client;
		}
		void SetCopyright(std::string copyright) {
			ICOP = copyright;
		}
		void SetSoftware(std::string software) {
			ISFT = software;
		}

		std::string GetTitle() {
			return INAM;
		}
		std::string GetProductName() {
			return IPRD;
		}
		std::string GetArtistName() {
			return IART;
		}
		std::string GetComment() {
			return ICMT;
		}
		std::string GetCreationDate() {
			return ICRD;
		}
		std::string GetGenre() {
			return IGNR;
		}
		std::string GetTrackNumber() {
			return ITRK;
		}
		std::string GetClient() {
			return ICMS;
		}
		std::string GetCopyright() {
			return ICOP;
		}
		std::string GetSoftware() {
			return ISFT;
		}

	};//*/

	//音諳の浮動小数点数型の音声データを.wavに保存する為のクラス
	template<>
	class NesoraWave<float> {
	private:

		std::vector<float> wave;

		nsuint samplingFreq = 44100;				//標本化周波数
		uint16_t channelNum = 1;					//チャンネル数
		uint16_t bitPerSample = 16;		//量子化ビット数

		std::string	INAM = "Nesora Voice";	//タイトル
		std::string	IPRD = "Nesora";	//アルバム名
		std::string IART = "MucchoSP";	//アーティスト名
		std::string	ICMT = "This is an audio file generated by Nesora.";	//コメント
		std::string	ICRD = "After 2024";	//作成日
		std::string	IGNR = "Voice";	//ジャンル
		std::string	ITRK = "0";	//トラック
		std::string	ICMS = "None";	//依頼者
		std::string	ICOP = "Copyright (c) MucchoSP";	//著作権情報
		std::string ISFT = "Nesora 0 type IV";	//ファイル作成に使用したソフトウエア名

	public:

		NesoraWave() {

		}
		NesoraWave(std::vector<float> w) {
			wave = w;
		}

		void SetWave(std::vector<float> w) {
			wave = w;
		}
		std::vector<float> GetWave() {
			return wave;
		}

		int SaveFile(std::string fileName) {
			std::ofstream file(fileName, std::ios::binary);

			if (!file)
				return -1;

			uint32_t work32 = 0;
			uint16_t work16 = 0;
			uint8_t work8 = 0;

			file << "RIFF";
			auto fileSize = file.tellp();
			work32 = 0;//riff chank size
			file.write((char*)&work32, 4);
			file << "WAVE";

			file << "fmt ";
			work32 = 16;					//format chank size
			file.write((char*)&work32, 4);
			work16 = 1;						//format tag(WAVE_FORMAT_PCM:PCM)
			file.write((char*)&work16, 2);
			file.write((char*)&channelNum, 2);
			file.write((char*)&samplingFreq, 4);
			work32 = samplingFreq * channelNum * (bitPerSample / 8);
			file.write((char*)&work32, 4);
			work16 = channelNum * (bitPerSample / 8);
			file.write((char*)&work16, 2);
			file.write((char*)&bitPerSample, 2);
			//fmt チャンクここまで

			std::vector<int16_t> wavedata(wave.size());
			for(size_t i = 0;i < wave.size();i++)
				wavedata[i] = (int16_t)(wave[i] * (INT16_MAX - 1));
			file << "data";
			int padding = 2;
			file.write((char*)&(work32 = wavedata.size() * (channelNum * bitPerSample / 8) + padding), 4);	//data chank size
			file.write((char*)wavedata.data(), wavedata.size() * (bitPerSample / 8));
			file.write((char*)&(work32 = 0), padding);
			//dataチャンクここまで

			work16 = 0;
			file << "LIST";
			auto ListSize = file.tellp();
			file.write((char*)&(work32 = 0), 4);
			file << "INFO";
			//製作者
			std::string workInfoString = IART;
			if (workInfoString != "") {
				file << "IART";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//依頼者
			workInfoString = ICMS;
			if (workInfoString != "") {
				file << "ICMS";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "ICMT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "ICOP";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "ICRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "IGNR";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "INAM";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "IPRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ソフトウエア名
			workInfoString = ISFT;
			if (workInfoString != "") {
				file << "ISFT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "ITRK";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}

			auto ListSize_work32 = file.tellp() - ListSize - 4;
			auto ListChankEnd = file.tellp();
			file.seekp(ListSize);
			file.write((char*)&ListSize_work32, 4);
			file.seekp(ListChankEnd);
			//LISTチャンクここまで


			file << "id3 ";
			auto id3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			file << "ID3";
			file.write((char*)&(work16 = 3), 2);
			file.write((char*)&(work8 = 0), 1);
			auto ID3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			int is_ShiftJIS = 1;
			//製作者
			workInfoString = IART;
			if (workInfoString != "") {
				file << "TPE1";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + is_ShiftJIS)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "COMM";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "TCOP";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "TDAT";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "TCON";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "TIT2";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "TALB";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ソフトウエア名
			// workInfoString = info.ISFT;
			// if (workInfoString == "")
			// 	workInfoString = "Nesora I type IV";
			// file << "ISFT";
			// file.write((char*)&(work8 = (workInfoString.size() >> 24) % 0xff), 1);
			// file.write((char*)&(work8 = (workInfoString.size() >> 16) % 0xff), 1);
			// file.write((char*)&(work8 = (workInfoString.size() >> 8) % 0xff), 1);
			// file.write((char*)&(work8 = workInfoString.size() % 0xff), 1);
			// file.write((char*)&(work16 = 0), 2);
			// file.write(workInfoString.data(), workInfoString.size());

			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "TRCK";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}

			auto ID3Size_work32 = file.tellp() - ID3Size - 4;
			auto id3Size_work32 = file.tellp() - id3Size - 4;
			auto fileSize_work32 = file.tellp() - fileSize - 4;
			file.seekp(ID3Size);
			file.write((char*)&(work8 = (ID3Size_work32 >> 21) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 14) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 7) % 0x7f), 1);
			file.write((char*)&(work8 = ID3Size_work32 % 0x7f), 1);
			//ID3 チャンクここまで

			file.seekp(id3Size);
			file.write((char*)&id3Size_work32, 4);
			//id3 チャンクここまで

			file.seekp(fileSize);
			file.write((char*)&fileSize_work32, 4);
			//RIFFチャンクここまで


			file.close();

			return 0;
		}

		void SetSamplingFrequency(nsuint samplingFrequency) {
			samplingFreq = samplingFrequency;
		}
		void SetChannelNumber(uint16_t channelNumber) {
			channelNum = channelNumber;
		}

		nsuint GetSamplingFrequency() {
			return samplingFreq;
		}
		uint16_t GetChannelNumber() {
			return channelNum;
		}
		uint16_t GetBitPerSample() {
			return bitPerSample;
		}

		void SetTitle(std::string title) {
			INAM = title;
		}
		void SetProductName(std::string name) {
			IPRD = name;
		}
		void SetArtistName(std::string name) {
			IART = name;
		}
		void SetComment(std::string comment) {
			ICMT = comment;
		}
		void SetCreationDate(std::string date) {
			ICRD = date;
		}
		void SetGenre(std::string genre) {
			IGNR = genre;
		}
		void SetTrackNumber(std::string number) {
			ITRK = number;
		}
		void SetClient(std::string client) {
			ICMS = client;
		}
		void SetCopyright(std::string copyright) {
			ICOP = copyright;
		}
		void SetSoftware(std::string software) {
			ISFT = software;
		}

		std::string GetTitle() {
			return INAM;
		}
		std::string GetProductName() {
			return IPRD;
		}
		std::string GetArtistName() {
			return IART;
		}
		std::string GetComment() {
			return ICMT;
		}
		std::string GetCreationDate() {
			return ICRD;
		}
		std::string GetGenre() {
			return IGNR;
		}
		std::string GetTrackNumber() {
			return ITRK;
		}
		std::string GetClient() {
			return ICMS;
		}
		std::string GetCopyright() {
			return ICOP;
		}
		std::string GetSoftware() {
			return ISFT;
		}

	};

	//音諳の浮動小数点数型の音声データを.wavに保存する為のクラス
	template<>
	class NesoraWave<double> {
	private:

		std::vector<float> wave;

		nsuint samplingFreq = 44100;				//標本化周波数
		uint16_t channelNum = 1;					//チャンネル数
		uint16_t bitPerSample = sizeof(float) * 8;		//量子化ビット数

		std::string	INAM = "Nesora Voice";	//タイトル
		std::string	IPRD = "Nesora";	//アルバム名
		std::string IART = "MucchoSP";	//アーティスト名
		std::string	ICMT = "This is an audio file generated by Nesora.";	//コメント
		std::string	ICRD = "After 2024";	//作成日
		std::string	IGNR = "Voice";	//ジャンル
		std::string	ITRK = "0";	//トラック
		std::string	ICMS = "None";	//依頼者
		std::string	ICOP = "Copyright (c) MucchoSP";	//著作権情報
		std::string ISFT = "Nesora 0 type IV";	//ファイル作成に使用したソフトウエア名

	public:

		NesoraWave() {

		}
		NesoraWave(std::vector<double> w) {
			wave.resize(w.size());
			for (size_t i = 0;i < w.size();i++)
				wave[i] = (float)w[i];
		}

		void SetWave(std::vector<double> w) {
			wave.resize(w.size());
			for (size_t i = 0;i < w.size();i++)
				wave[i] = (float)w[i];
		}
		std::vector<float> GetWave() {
			return wave;
		}

		int SaveFile(std::string fileName) {
			std::ofstream file(fileName, std::ios::binary);

			if (!file)
				return -1;

			uint32_t work32 = 0;
			uint16_t work16 = 0;
			uint8_t work8 = 0;

			file << "RIFF";
			auto fileSize = file.tellp();
			work32 = 0;//riff chank size
			file.write((char*)&work32, 4);
			file << "WAVE";

			file << "fmt ";
			work32 = 16;					//format chank size
			file.write((char*)&work32, 4);
			work16 = 3;						//format tag(WAVE_FORMAT_IEEE_FLOAT:IEEE float)
			file.write((char*)&work16, 2);
			file.write((char*)&channelNum, 2);
			file.write((char*)&samplingFreq, 4);
			work32 = samplingFreq * channelNum * (bitPerSample / 8);
			file.write((char*)&work32, 4);
			work16 = channelNum * (bitPerSample / 8);
			file.write((char*)&work16, 2);
			file.write((char*)&bitPerSample, 2);
			//fmt チャンクここまで

			file << "data";
			int padding = 2 /*- wave.size() % 2*/;
			file.write((char*)&(work32 = wave.size() * (channelNum * bitPerSample / 8) + padding), 4);	//data chank size
			file.write((char*)wave.data(), wave.size() * (bitPerSample / 8));
			file.write((char*)&(work32 = 0), padding);
			//dataチャンクここまで

			work16 = 0;
			file << "LIST";
			auto ListSize = file.tellp();
			file.write((char*)&(work32 = 0), 4);
			file << "INFO";
			//製作者
			std::string workInfoString = IART;
			if (workInfoString != "") {
				file << "IART";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//依頼者
			workInfoString = ICMS;
			if (workInfoString != "") {
				file << "ICMS";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "ICMT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "ICOP";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "ICRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "IGNR";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "INAM";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "IPRD";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//ソフトウエア名
			workInfoString = ISFT;
			if (workInfoString != "") {
				file << "ISFT";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}
			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "ITRK";
				file.write((char*)&(work32 = workInfoString.size() + (2 - workInfoString.size() % 2)), 4);
				file.write(workInfoString.data(), workInfoString.size());
				file.write((char*)&(work16 = 0), (std::streamsize)(2 - workInfoString.size() % 2));
			}

			auto ListSize_work32 = file.tellp() - ListSize - 4;
			auto ListChankEnd = file.tellp();
			file.seekp(ListSize);
			file.write((char*)&ListSize_work32, 4);
			file.seekp(ListChankEnd);
			//LISTチャンクここまで


			file << "id3 ";
			auto id3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			file << "ID3";
			file.write((char*)&(work16 = 3), 2);
			file.write((char*)&(work8 = 0), 1);
			auto ID3Size = file.tellp();
			file.write((char*)&(work32 = 0), 4);

			int is_ShiftJIS = 1;
			//製作者
			workInfoString = IART;
			if (workInfoString != "") {
				file << "TPE1";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + is_ShiftJIS)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//コメント
			workInfoString = ICMT;
			if (workInfoString != "") {
				file << "COMM";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//著作権情報
			workInfoString = ICOP;
			if (workInfoString != "") {
				file << "TCOP";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//作成日
			workInfoString = ICRD;
			if (workInfoString != "") {
				file << "TDAT";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ジャンル
			workInfoString = IGNR;
			if (workInfoString != "") {
				file << "TCON";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//タイトル
			workInfoString = INAM;
			if (workInfoString != "") {
				file << "TIT2";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//アルバム名
			workInfoString = IPRD;
			if (workInfoString != "") {
				file << "TALB";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}
			//ソフトウエア名
			/*workInfoString = info.ISFT;
			if (workInfoString == "")
				workInfoString = "Nesora I type IV";
			file << "ISFT";
			file.write((char*)&(work8 = (workInfoString.size() >> 24) % 0xff), 1);
			file.write((char*)&(work8 = (workInfoString.size() >> 16) % 0xff), 1);
			file.write((char*)&(work8 = (workInfoString.size() >> 8) % 0xff), 1);
			file.write((char*)&(work8 = workInfoString.size() % 0xff), 1);
			file.write((char*)&(work16 = 0), 2);
			file.write(workInfoString.data(), workInfoString.size());*/

			//トラック
			workInfoString = ITRK;
			if (workInfoString != "") {
				file << "TRCK";
				int dataSize = workInfoString.size() + is_ShiftJIS;
				file.write((char*)&(work8 = (dataSize >> 24) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 16) % 0xff), 1);
				file.write((char*)&(work8 = (dataSize >> 8) % 0xff), 1);
				file.write((char*)&(work8 = dataSize % 0xff), 1);
				file.write((char*)&(work32 = 0), (std::streamsize)((int)(2 + dataSize)));
				file.write(workInfoString.data(), workInfoString.size());
			}

			auto ID3Size_work32 = file.tellp() - ID3Size - 4;
			auto id3Size_work32 = file.tellp() - id3Size - 4;
			auto fileSize_work32 = file.tellp() - fileSize - 4;
			file.seekp(ID3Size);
			file.write((char*)&(work8 = (ID3Size_work32 >> 21) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 14) % 0x7f), 1);
			file.write((char*)&(work8 = (ID3Size_work32 >> 7) % 0x7f), 1);
			file.write((char*)&(work8 = ID3Size_work32 % 0x7f), 1);
			//ID3 チャンクここまで

			file.seekp(id3Size);
			file.write((char*)&id3Size_work32, 4);
			//id3 チャンクここまで

			file.seekp(fileSize);
			file.write((char*)&fileSize_work32, 4);
			//RIFFチャンクここまで


			file.close();

			return 0;
		}

		void SetSamplingFrequency(nsuint samplingFrequency) {
			samplingFreq = samplingFrequency;
		}
		void SetChannelNumber(uint16_t channelNumber) {
			channelNum = channelNumber;
		}

		nsuint GetSamplingFrequency() {
			return samplingFreq;
		}
		uint16_t GetChannelNumber() {
			return channelNum;
		}
		uint16_t GetBitPerSample() {
			return bitPerSample;
		}

		void SetTitle(std::string title) {
			INAM = title;
		}
		void SetProductName(std::string name) {
			IPRD = name;
		}
		void SetArtistName(std::string name) {
			IART = name;
		}
		void SetComment(std::string comment) {
			ICMT = comment;
		}
		void SetCreationDate(std::string date) {
			ICRD = date;
		}
		void SetGenre(std::string genre) {
			IGNR = genre;
		}
		void SetTrackNumber(std::string number) {
			ITRK = number;
		}
		void SetClient(std::string client) {
			ICMS = client;
		}
		void SetCopyright(std::string copyright) {
			ICOP = copyright;
		}
		void SetSoftware(std::string software) {
			ISFT = software;
		}

		std::string GetTitle() {
			return INAM;
		}
		std::string GetProductName() {
			return IPRD;
		}
		std::string GetArtistName() {
			return IART;
		}
		std::string GetComment() {
			return ICMT;
		}
		std::string GetCreationDate() {
			return ICRD;
		}
		std::string GetGenre() {
			return IGNR;
		}
		std::string GetTrackNumber() {
			return ITRK;
		}
		std::string GetClient() {
			return ICMS;
		}
		std::string GetCopyright() {
			return ICOP;
		}
		std::string GetSoftware() {
			return ISFT;
		}

	};

}//namespace nesora


